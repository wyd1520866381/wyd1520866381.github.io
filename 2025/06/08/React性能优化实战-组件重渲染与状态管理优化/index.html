<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>React 性能优化实战（三）：组件重渲染与状态管理优化 | Edon Wang's Blog</title><meta name="author" content="Edon Wang(王艺栋)"><meta name="copyright" content="Edon Wang(王艺栋)"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="文章简介聚焦 React 组件的重渲染机制与状态管理，梳理常见的性能陷阱与优化技巧，提升应用响应速度。 主要内容组件重渲染的触发机制 父组件重新渲染会导致所有子组件默认也重新渲染（除非被 React.memo 包裹） props 变化、state 变化、context 变化都会触发组件重渲染 forceUpdate、key 变化等也会导致组件重新挂载  代码示例：父组件更新导致子组件重渲染1234">
<meta property="og:type" content="article">
<meta property="og:title" content="React 性能优化实战（三）：组件重渲染与状态管理优化">
<meta property="og:url" content="http://edon.website/2025/06/08/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E7%BB%84%E4%BB%B6%E9%87%8D%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="Edon Wang&#39;s Blog">
<meta property="og:description" content="文章简介聚焦 React 组件的重渲染机制与状态管理，梳理常见的性能陷阱与优化技巧，提升应用响应速度。 主要内容组件重渲染的触发机制 父组件重新渲染会导致所有子组件默认也重新渲染（除非被 React.memo 包裹） props 变化、state 变化、context 变化都会触发组件重渲染 forceUpdate、key 变化等也会导致组件重新挂载  代码示例：父组件更新导致子组件重渲染1234">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://edon.website/images/default-cover.png">
<meta property="article:published_time" content="2025-06-08T02:00:00.000Z">
<meta property="article:modified_time" content="2025-06-23T01:55:27.408Z">
<meta property="article:author" content="Edon Wang(王艺栋)">
<meta property="article:tag" content="React">
<meta property="article:tag" content="性能优化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://edon.website/images/default-cover.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "React 性能优化实战（三）：组件重渲染与状态管理优化",
  "url": "http://edon.website/2025/06/08/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E7%BB%84%E4%BB%B6%E9%87%8D%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96/",
  "image": "http://edon.website/images/default-cover.png",
  "datePublished": "2025-06-08T02:00:00.000Z",
  "dateModified": "2025-06-23T01:55:27.408Z",
  "author": [
    {
      "@type": "Person",
      "name": "Edon Wang(王艺栋)",
      "url": "http://edon.website"
    }
  ]
}</script><link rel="shortcut icon" href="/images/ico.ico"><link rel="canonical" href="http://edon.website/2025/06/08/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E7%BB%84%E4%BB%B6%E9%87%8D%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#1a1a1a')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Edon Wang(王艺栋)","link":"链接: ","source":"来源: Edon Wang's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'React 性能优化实战（三）：组件重渲染与状态管理优化',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0">

<script type="application/ld+json" id="hexo-seo-schema">[
  {
    "@context": "http://schema.org",
    "@type": "WebSite",
    "url": "http://edon.website",
    "potentialAction": {
      "@type": "SearchAction",
      "@id": "https://developers.google.com/search/docs/advanced/structured-data/sitelinks-searchbox",
      "target": "http://www.edon.website{search_term_string}",
      "query-input": "required name=search_term_string"
    }
  },
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "@id": "https://developers.google.com/search/docs/advanced/structured-data/breadcrumb",
    "name": "breadcrumb",
    "itemListElement": [
      {
        "@type": "ListItem",
        "position": 1,
        "item": "http://edon.website/tags/React/",
        "name": "React"
      },
      {
        "@type": "ListItem",
        "position": 2,
        "item": "http://edon.website/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/",
        "name": "性能优化"
      },
      {
        "@type": "ListItem",
        "position": 3,
        "item": "http://edon.website/categories/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/",
        "name": "技术专题"
      },
      {
        "@type": "ListItem",
        "position": 4,
        "item": "http://edon.website/categories/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/React/",
        "name": "React"
      },
      {
        "@type": "ListItem",
        "position": 5,
        "item": "http://edon.website/2025/06/08/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E7%BB%84%E4%BB%B6%E9%87%8D%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96/",
        "name": "React 性能优化实战（三）：组件重渲染与状态管理优化"
      }
    ]
  },
  {
    "@context": "https://schema.org/",
    "@type": "Article",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http://edon.website/2025/06/08/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E7%BB%84%E4%BB%B6%E9%87%8D%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96/"
    },
    "headline": "React 性能优化实战（三）：组件重渲染与状态管理优化",
    "description": "React 性能优化实战（三）：组件重渲染与状态管理优化",
    "image": {
      "@type": "ImageObject",
      "url": "/images/default-cover.png",
      "width": "250",
      "height": "250"
    },
    "author": {
      "@type": "Person",
      "name": "Edon Wang(王艺栋)"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Edon Wang(王艺栋)",
      "logo": {
        "@type": "ImageObject",
        "url": "https://www.webmanajemen.com/2022/01/04/frp-redmi-go-tiare-fix/Bypass%20FRP%20Redmi%20Go%20Tiare%20M1903C3GG.jpg",
        "width": "125",
        "height": "125"
      }
    },
    "datePublished": "2025-06-08T10:00:00+08:00",
    "dateModified": "2025-06-23T09:55:27+08:00"
  }
]</script>

<link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml" ></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/styles/minimal.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar" title="avatar" itemprop="image"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/projects/"><i class="fa-fw fas fa-project-diagram"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/default-cover.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Edon Wang's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">React 性能优化实战（三）：组件重渲染与状态管理优化</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/projects/"><i class="fa-fw fas fa-project-diagram"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">React 性能优化实战（三）：组件重渲染与状态管理优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-08T02:00:00.000Z" title="发表于 2025-06-08 10:00:00">2025-06-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-23T01:55:27.408Z" title="更新于 2025-06-23 09:55:27">2025-06-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/">技术专题</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/React/">React</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>聚焦 React 组件的重渲染机制与状态管理，梳理常见的性能陷阱与优化技巧，提升应用响应速度。</p>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><h2 id="组件重渲染的触发机制"><a href="#组件重渲染的触发机制" class="headerlink" title="组件重渲染的触发机制"></a>组件重渲染的触发机制</h2><ul>
<li>父组件重新渲染会导致所有子组件默认也重新渲染（除非被 React.memo 包裹）</li>
<li>props 变化、state 变化、context 变化都会触发组件重渲染</li>
<li>forceUpdate、key 变化等也会导致组件重新挂载</li>
</ul>
<h3 id="代码示例：父组件更新导致子组件重渲染"><a href="#代码示例：父组件更新导致子组件重渲染" class="headerlink" title="代码示例：父组件更新导致子组件重渲染"></a>代码示例：父组件更新导致子组件重渲染</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, memo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ChildProps</span> = &#123; <span class="attr">value</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">memo</span>(<span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">&#123; value &#125;: <span class="title class_">ChildProps</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Child render&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [other, setOther] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;count+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setOther(other + 1)&#125;&gt;other+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">value</span>=<span class="string">&#123;count&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击 other+1 时，Child 组件不会重新渲染。</p>
<h2 id="props、state-变化对渲染的影响"><a href="#props、state-变化对渲染的影响" class="headerlink" title="props、state 变化对渲染的影响"></a>props、state 变化对渲染的影响</h2><ul>
<li>props 变化会触发子组件渲染（可用 React.memo 优化）</li>
<li>state 变化只影响当前组件及其子树</li>
<li>context 变化会影响所有消费该 context 的组件</li>
</ul>
<h2 id="React-memo、useMemo、useCallback-的使用场景"><a href="#React-memo、useMemo、useCallback-的使用场景" class="headerlink" title="React.memo、useMemo、useCallback 的使用场景"></a>React.memo、useMemo、useCallback 的使用场景</h2><ul>
<li><strong>React.memo</strong>：用于包裹函数组件，避免 props 未变时的重复渲染</li>
<li><strong>useMemo</strong>：缓存计算结果，避免重复计算</li>
<li><strong>useCallback</strong>：缓存函数引用，避免因函数变化导致子组件重复渲染</li>
</ul>
<h3 id="代码示例：useMemo-useCallback-优化"><a href="#代码示例：useMemo-useCallback-优化" class="headerlink" title="代码示例：useMemo&#x2F;useCallback 优化"></a>代码示例：useMemo&#x2F;useCallback 优化</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useMemo, useCallback &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Expensive</span>(<span class="params">&#123; num &#125;: &#123; num: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 假设是复杂计算</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) sum += i * num;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;, [num]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;result&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> <span class="title function_">setN</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> v + <span class="number">1</span>), []);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>n+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Expensive</span> <span class="attr">num</span>=<span class="string">&#123;n&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状态提升与局部状态管理"><a href="#状态提升与局部状态管理" class="headerlink" title="状态提升与局部状态管理"></a>状态提升与局部状态管理</h2><ul>
<li>状态提升：将多个组件共享的 state 提升到最近的公共父组件</li>
<li>局部状态：只在需要的组件内维护 state，避免全局状态污染</li>
<li>合理拆分 state，减少无关组件的重渲染</li>
</ul>
<h2 id="Redux-MobX-等状态管理优化实践"><a href="#Redux-MobX-等状态管理优化实践" class="headerlink" title="Redux&#x2F;MobX 等状态管理优化实践"></a>Redux&#x2F;MobX 等状态管理优化实践</h2><ul>
<li>Redux 推荐使用 selector + useSelector，避免全量订阅</li>
<li>使用 immer&#x2F;Redux Toolkit 简化不可变数据操作</li>
<li>MobX 可通过 @observer 精细控制响应式渲染</li>
<li>状态切片、模块化管理，提升可维护性</li>
</ul>
<h3 id="代码示例：Redux-useSelector-优化"><a href="#代码示例：Redux-useSelector-优化" class="headerlink" title="代码示例：Redux useSelector 优化"></a>代码示例：Redux useSelector 优化</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useSelector &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">useSelector</span>(<span class="function">(<span class="params"><span class="attr">state</span>: <span class="built_in">any</span></span>) =&gt;</span> state.<span class="property">some</span>.<span class="property">value</span>);</span><br><span class="line">  <span class="comment">// 只在 value 变化时渲染</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="个人经验"><a href="#个人经验" class="headerlink" title="个人经验"></a>个人经验</h2><ul>
<li>实际项目中，优先用 React.memo 包裹纯展示组件</li>
<li>复杂组件拆分局部 state，减少全局依赖</li>
<li>Redux&#x2F;MobX 状态管理时，注意 selector 粒度，避免全量订阅</li>
<li>善用 useMemo&#x2F;useCallback 优化性能，但避免滥用</li>
<li>定期用 Profiler 工具分析渲染瓶颈，持续优化</li>
</ul>
<p>结合实际项目，分享避免无效渲染和高效管理状态的方法。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://edon.website" rel="internal follow bookmark" hexo-seo="true" alt="React 性能优化实战（三）：组件重渲染与状态管理优化" title="React 性能优化实战（三）：组件重渲染与状态管理优化">Edon Wang(王艺栋)</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://edon.website/2025/06/08/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E7%BB%84%E4%BB%B6%E9%87%8D%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96/" rel="internal follow bookmark" hexo-seo="true" alt="React 性能优化实战（三）：组件重渲染与状态管理优化" title="React 性能优化实战（三）：组件重渲染与状态管理优化">http://edon.website/2025/06/08/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E7%BB%84%E4%BB%B6%E9%87%8D%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="nofollow noopener noreferer noreferrer external" hexo-seo="true" alt="React 性能优化实战（三）：组件重渲染与状态管理优化" title="React 性能优化实战（三）：组件重渲染与状态管理优化">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://edon.website" target="_blank" rel="internal follow bookmark" hexo-seo="true" alt="React 性能优化实战（三）：组件重渲染与状态管理优化" title="React 性能优化实战（三）：组件重渲染与状态管理优化">Edon Wang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React/">React</a><a class="post-meta__tags" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></div><div class="post-share"><div class="social-share" data-image="/images/default-cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/15/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E5%AE%9E%E8%B7%B5/" title="React 性能优化实战（四）：懒加载与代码分割实践"><img class="cover" src="/images/default-cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post" title="cover of previous post" itemprop="image"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">React 性能优化实战（四）：懒加载与代码分割实践</div></div><div class="info-2"><div class="info-item-1">文章简介介绍 React 应用中的懒加载与代码分割技术，提升首屏加载速度和整体性能体验。 主要内容1. 代码分割的原理与意义代码分割（Code Splitting）是将应用的代码拆分为多个包，按需加载，减少首屏加载体积，提升页面响应速度。React18 支持基于路由、组件等多维度的代码分割。 2. React.lazy 与 Suspense 的用法React.lazy 允许你用动态 import 的方式按需加载组件，Suspense 用于包裹懒加载组件并自定义加载状态。 12345678910111213141516171819// src/pages/About.tsximport React from &quot;react&quot;;export default function About() &#123;  return &lt;div&gt;About Page&lt;/div&gt;;&#125;// src/App.tsximport React, &#123; Suspense, lazy &#125; from &quot;react&quot;;const...</div></div></div></a><a class="pagination-related" href="/2025/05/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F3D%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/" title="微信小程序3D项目创建"><img class="cover" src="/images/default-cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post" title="cover of next post" itemprop="image"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">微信小程序3D项目创建</div></div><div class="info-2"><div class="info-item-1">微信小程序 3D：原生框架与 H5 套壳的深度解析在微信小程序生态中，开发者面临着两种主流的 3D 实现路径：基于原生框架的 XR-Frame 与基于 H5 技术栈的套壳方案。理解两者的核心差异，对于选择最适合项目需求的技术方案至关重要。 原生 XR-Frame：性能与深度的融合微信小程序官方推出的 XR-Frame，是专为小程序环境量身打造的 XR&#x2F;3D 应用解决方案。它并非简单的 H5 封装，而是基于混合方案实现，旨在提供接近原生应用的性能体验。XR-Frame 的优势在于：  性能逼近原生：通过底层优化，XR-Frame 能够更高效地利用设备硬件资源，减少渲染延迟，提供流畅的 3D 交互体验。这对于对性能要求较高的复杂 3D 场景尤为关键。 深度集成：XR-Frame 与微信小程序生态系统深度融合，能够无缝调用小程序 API，实现更丰富的功能，例如与微信支付、用户数据、设备传感器等进行高效互动。 易用性与扩展性：XR-Frame 遵循小程序开发标准，降低了开发者的学习门槛。同时，其模块化的设计也提供了良好的扩展性，方便开发者根据需求定制功能。 官方支持与维护：作为...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/21/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/" title="React 性能优化实战（一）：性能瓶颈分析方法"><img class="cover" src="/images/default-cover.png" alt="cover" title="cover" itemprop="image"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-21</div><div class="info-item-2">React 性能优化实战（一）：性能瓶颈分析方法</div></div><div class="info-2"><div class="info-item-1">文章简介介绍在 React 项目中常见的性能瓶颈类型，梳理定位和分析性能问题的常用方法与工具，为后续优化打下基础。 主要内容性能瓶颈的常见表现 首屏加载慢，白屏时间长 页面滚动、动画卡顿，FPS 低 交互响应迟钝，点击、输入延迟 组件频繁重渲染，CPU 占用高 内存泄漏，页面长时间运行后变慢甚至崩溃  性能分析的基本思路 明确性能目标与关键指标（如 FCP、TTI、LCP、FPS 等） 复现性能问题，收集相关数据 利用工具定位瓶颈（网络、渲染、JS 执行、内存等） 结合代码结构分析，找出根因 制定并验证优化方案  浏览器性能分析工具1. Chrome DevTools Performance 面板：录制页面性能快照，分析 JS 执行、渲染、重排重绘等耗时 Memory 面板：检测内存泄漏、对象分配 Network 面板：分析资源加载瓶颈  常用操作 录制性能快照，查找长任务（Long Task） 查看 Main 线程耗时分布 分析 Timeline，定位卡顿点  2. React Profiler用于分析组件渲染耗时、识别不必要的重渲染。 使用方法（React 18 + Type...</div></div></div></a><a class="pagination-related" href="/2025/06/21/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/" title="React 性能优化实战（五）：性能监控与调优工具"><img class="cover" src="/images/default-cover.png" alt="cover" title="cover" itemprop="image"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-21</div><div class="info-item-2">React 性能优化实战（五）：性能监控与调优工具</div></div><div class="info-2"><div class="info-item-1">文章简介梳理 React 项目中常用的性能监控与调优工具，介绍如何持续追踪和优化应用性能。 主要内容性能监控的意义与核心指标在现代 React 应用中，性能直接影响用户体验和业务转化。常见的性能监控核心指标包括：  FP&#x2F;FCP（First Paint&#x2F;First Contentful Paint）：首屏渲染时间，衡量页面首次可见内容的速度。 TTI（Time to Interactive）：页面可交互时间。 LCP（Largest Contentful Paint）：最大内容绘制时间。 FID（First Input Delay）：首次输入延迟。 CLS（Cumulative Layout Shift）：累计布局偏移。 FPS（Frames Per Second）：帧率，衡量动画流畅度。  这些指标可通过 Web Vitals、Lighthouse 等工具自动采集。 常用性能监控与分析工具1. Chrome DevTools Performance 面板：录制和分析页面渲染、JS 执行、网络请求等。 Memory 面板：检测内存泄漏和对象分配。 Networ...</div></div></div></a><a class="pagination-related" href="/2025/06/15/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E5%AE%9E%E8%B7%B5/" title="React 性能优化实战（四）：懒加载与代码分割实践"><img class="cover" src="/images/default-cover.png" alt="cover" title="cover" itemprop="image"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-15</div><div class="info-item-2">React 性能优化实战（四）：懒加载与代码分割实践</div></div><div class="info-2"><div class="info-item-1">文章简介介绍 React 应用中的懒加载与代码分割技术，提升首屏加载速度和整体性能体验。 主要内容1. 代码分割的原理与意义代码分割（Code Splitting）是将应用的代码拆分为多个包，按需加载，减少首屏加载体积，提升页面响应速度。React18 支持基于路由、组件等多维度的代码分割。 2. React.lazy 与 Suspense 的用法React.lazy 允许你用动态 import 的方式按需加载组件，Suspense 用于包裹懒加载组件并自定义加载状态。 12345678910111213141516171819// src/pages/About.tsximport React from &quot;react&quot;;export default function About() &#123;  return &lt;div&gt;About Page&lt;/div&gt;;&#125;// src/App.tsximport React, &#123; Suspense, lazy &#125; from &quot;react&quot;;const...</div></div></div></a><a class="pagination-related" href="/2025/05/28/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/" title="React 性能优化实战（二）：渲染机制与优化原理"><img class="cover" src="/images/default-cover.png" alt="cover" title="cover" itemprop="image"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-28</div><div class="info-item-2">React 性能优化实战（二）：渲染机制与优化原理</div></div><div class="info-2"><div class="info-item-1">文章简介深入解析 React 的渲染机制，包括虚拟 DOM、Diff 算法、Fiber 架构等，帮助开发者理解性能优化的底层原理。 主要内容虚拟 DOM 与真实 DOM 的关系React 通过虚拟 DOM（VDOM）实现高效的 UI 更新。每次状态变更时，React 会生成新的虚拟 DOM 树，与上一次的虚拟 DOM 进行对比（Diff），最终只将差异部分同步到真实 DOM，减少了直接操作 DOM 的性能开销。 示例：虚拟 DOM 更新流程1234567891011import React, &#123; useState &#125; from &quot;react&quot;;export default function Counter() &#123;  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;span&gt;&#123;count&#125;&lt;/span&gt;      &lt;button onClick=&#123;() =&gt; setCount(...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar" title="avatar" itemprop="image"></div><div class="author-info-name">Edon Wang(王艺栋)</div><div class="author-info-description">你好，我是Edon Wang(王艺栋)，一名充满热情的开发者，在前端、WebGL、元宇宙和AR/VR领域有多年经验。欢迎来到我的博客！</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" href="mailto:wyd0617@qq.com"><i class="fas fa-envelope"></i><span>联系我</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:wyd0617@qq.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://github.com/wyd1520866381" target="_blank" title="Github" rel="nofollow noopener noreferer noreferrer external" hexo-seo="true" alt="React 性能优化实战（三）：组件重渲染与状态管理优化"><i class="fab fa-github" style="color: #hdhfbb;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">WeChat: wyd1520866381<br>QQ: 1520866381</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">文章简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="toc-number">2.</span> <span class="toc-text">主要内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%87%8D%E6%B8%B2%E6%9F%93%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">组件重渲染的触发机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%88%B6%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4%E5%AD%90%E7%BB%84%E4%BB%B6%E9%87%8D%E6%B8%B2%E6%9F%93"><span class="toc-number">3.1.</span> <span class="toc-text">代码示例：父组件更新导致子组件重渲染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#props%E3%80%81state-%E5%8F%98%E5%8C%96%E5%AF%B9%E6%B8%B2%E6%9F%93%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">4.</span> <span class="toc-text">props、state 变化对渲染的影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-memo%E3%80%81useMemo%E3%80%81useCallback-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.</span> <span class="toc-text">React.memo、useMemo、useCallback 的使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9AuseMemo-useCallback-%E4%BC%98%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text">代码示例：useMemo&#x2F;useCallback 优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87%E4%B8%8E%E5%B1%80%E9%83%A8%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">状态提升与局部状态管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redux-MobX-%E7%AD%89%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.</span> <span class="toc-text">Redux&#x2F;MobX 等状态管理优化实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9ARedux-useSelector-%E4%BC%98%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">代码示例：Redux useSelector 优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C"><span class="toc-number">8.</span> <span class="toc-text">个人经验</span></a></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>系列文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/21/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/" title="React 性能优化实战（五）：性能监控与调优工具"><img src="/images/default-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React 性能优化实战（五）：性能监控与调优工具" title="React 性能优化实战（五）：性能监控与调优工具" itemprop="image"></a><div class="content"><a class="title" href="/2025/06/21/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/" title="React 性能优化实战（五）：性能监控与调优工具">React 性能优化实战（五）：性能监控与调优工具</a><time datetime="2025-06-21T02:00:00.000Z" title="发表于 2025-06-21 10:00:00">2025-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/15/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E5%AE%9E%E8%B7%B5/" title="React 性能优化实战（四）：懒加载与代码分割实践"><img src="/images/default-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React 性能优化实战（四）：懒加载与代码分割实践" title="React 性能优化实战（四）：懒加载与代码分割实践" itemprop="image"></a><div class="content"><a class="title" href="/2025/06/15/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E5%AE%9E%E8%B7%B5/" title="React 性能优化实战（四）：懒加载与代码分割实践">React 性能优化实战（四）：懒加载与代码分割实践</a><time datetime="2025-06-15T02:00:00.000Z" title="发表于 2025-06-15 10:00:00">2025-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/08/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E7%BB%84%E4%BB%B6%E9%87%8D%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96/" title="React 性能优化实战（三）：组件重渲染与状态管理优化"><img src="/images/default-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React 性能优化实战（三）：组件重渲染与状态管理优化" title="React 性能优化实战（三）：组件重渲染与状态管理优化" itemprop="image"></a><div class="content"><a class="title" href="/2025/06/08/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E7%BB%84%E4%BB%B6%E9%87%8D%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96/" title="React 性能优化实战（三）：组件重渲染与状态管理优化">React 性能优化实战（三）：组件重渲染与状态管理优化</a><time datetime="2025-06-08T02:00:00.000Z" title="发表于 2025-06-08 10:00:00">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/28/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/" title="React 性能优化实战（二）：渲染机制与优化原理"><img src="/images/default-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React 性能优化实战（二）：渲染机制与优化原理" title="React 性能优化实战（二）：渲染机制与优化原理" itemprop="image"></a><div class="content"><a class="title" href="/2025/05/28/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/" title="React 性能优化实战（二）：渲染机制与优化原理">React 性能优化实战（二）：渲染机制与优化原理</a><time datetime="2025-05-28T02:00:00.000Z" title="发表于 2025-05-28 10:00:00">2025-05-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/21/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/" title="React 性能优化实战（一）：性能瓶颈分析方法"><img src="/images/default-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React 性能优化实战（一）：性能瓶颈分析方法" title="React 性能优化实战（一）：性能瓶颈分析方法" itemprop="image"></a><div class="content"><a class="title" href="/2025/05/21/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98-%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/" title="React 性能优化实战（一）：性能瓶颈分析方法">React 性能优化实战（一）：性能瓶颈分析方法</a><time datetime="2025-05-21T02:00:00.000Z" title="发表于 2025-05-21 10:00:00">2025-05-21</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/19/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B-%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%8F%90%E7%A4%BA%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/" title="提示词工程（二）：高级提示技术与应用实践"><img src="/images/default-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="提示词工程（二）：高级提示技术与应用实践" title="提示词工程（二）：高级提示技术与应用实践" itemprop="image"></a><div class="content"><a class="title" href="/2025/08/19/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B-%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%8F%90%E7%A4%BA%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/" title="提示词工程（二）：高级提示技术与应用实践">提示词工程（二）：高级提示技术与应用实践</a><time datetime="2025-08-19T09:30:00.000Z" title="发表于 2025-08-19 17:30:00">2025-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/19/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B-%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="提示词工程（一）：基本概念与设计原则"><img src="/images/default-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="提示词工程（一）：基本概念与设计原则" title="提示词工程（一）：基本概念与设计原则" itemprop="image"></a><div class="content"><a class="title" href="/2025/08/19/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B-%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="提示词工程（一）：基本概念与设计原则">提示词工程（一）：基本概念与设计原则</a><time datetime="2025-08-19T09:00:00.000Z" title="发表于 2025-08-19 17:00:00">2025-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/18/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86-%E6%BF%80%E5%8A%B1%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%BA%E6%89%8D%E6%88%90%E9%95%BF/" title="团队管理（五）：激励机制与人才成长"><img src="/images/default-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="团队管理（五）：激励机制与人才成长" title="团队管理（五）：激励机制与人才成长" itemprop="image"></a><div class="content"><a class="title" href="/2025/08/18/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86-%E6%BF%80%E5%8A%B1%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%BA%E6%89%8D%E6%88%90%E9%95%BF/" title="团队管理（五）：激励机制与人才成长">团队管理（五）：激励机制与人才成长</a><time datetime="2025-08-18T02:30:00.000Z" title="发表于 2025-08-18 10:30:00">2025-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/17/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%E4%B8%8E%E7%9F%A5%E8%AF%86%E6%B2%89%E6%B7%80/" title="团队管理（四）：技术分享与知识沉淀"><img src="/images/default-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="团队管理（四）：技术分享与知识沉淀" title="团队管理（四）：技术分享与知识沉淀" itemprop="image"></a><div class="content"><a class="title" href="/2025/08/17/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%E4%B8%8E%E7%9F%A5%E8%AF%86%E6%B2%89%E6%B7%80/" title="团队管理（四）：技术分享与知识沉淀">团队管理（四）：技术分享与知识沉淀</a><time datetime="2025-08-17T02:30:00.000Z" title="发表于 2025-08-17 10:30:00">2025-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/23/Trae%E6%99%BA%E8%83%BD%E4%BD%93-Antd%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B8%AD%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E4%B8%93%E5%AE%B6/" title="Trae智能体-Antd全家桶中后台开发专家"><img src="/images/default-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Trae智能体-Antd全家桶中后台开发专家" title="Trae智能体-Antd全家桶中后台开发专家" itemprop="image"></a><div class="content"><a class="title" href="/2025/07/23/Trae%E6%99%BA%E8%83%BD%E4%BD%93-Antd%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B8%AD%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E4%B8%93%E5%AE%B6/" title="Trae智能体-Antd全家桶中后台开发专家">Trae智能体-Antd全家桶中后台开发专家</a><time datetime="2025-07-23T06:15:50.000Z" title="发表于 2025-07-23 14:15:50">2025-07-23</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Edon Wang(王艺栋)</span></div><div class="footer_custom_text"><a href="https://beian.miit.gov.cn" target="_blank" rel="nofollow noopener noreferer noreferrer external" hexo-seo="true" alt="React 性能优化实战（三）：组件重渲染与状态管理优化" title="React 性能优化实战（三）：组件重渲染与状态管理优化">辽ICP备2025057989号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>